{"version":3,"sources":["app/components/Keyboard.tsx","app/components/SourceLink.tsx","app/components/ScreenHeader.tsx","app/components/TextBlock.tsx","../../neuralnet/nnet.js","../../neuralnet/textnnet.js","app/GameScreen.tsx","app/components/HistoryChart.tsx","app/gameUtils.ts","app/constants/gameConstants.ts","App.tsx"],"names":["SpecialKeyboardKeys","HOME_URL","styles","StyleSheet","create","container","position","right","top","subtitle","color","fontWeight","fontSize","SourceLink","View","style","Text","accessibilityRole","href","onPress","Platform","OS","Linking","openURL","undefined","ScreenHeader","Box","sx","width","textAlign","Typography","variant","component","gutterBottom","TextBlockState","keySequence","row","flexDirection","marginBottom","cell","padding","paddingHorizontal","margin","borderRadius","borderWidth","borderColor","cellDisabled","text","textDisabled","Keyboard","props","onKeyPress","disabledKeyList","map","rowIndex","key","isDisabled","includes","Pressable","disabled","ColorMap","GUESS","CORRECT","POSSIBLE","INCORRECT","height","alignItems","justifyContent","TextBlock","state","backgroundColor","toUpperCase","NNEt","inputs","numberOfNodes","numberOfLayers","outputs","learningRate","randomInitialWeights","momentum","this","layers","globalError","i","push","inputId","length","Node","layer","node","weights","bias","forEach","ii","expectedOutputs","error","lastInputs","allOutputs","activateAllLayers","previousLayersDeltas","Array","apply","nextLayersDelta","thisLayersInput","nodeDelta","outputDelta","train","delta","layerInputs","layerOutputs","fire","startingWeight","weight","previousAdjustments","correction","actualOutput","activation","weightAdjustment","sigmoidDerivative","momentumAdjustment","Error","output","sigmoid","random","Math","x","smaller","exp","fx","sum","textInputs","nonTextInputs","outputChars","outputUpperCase","nonTextOutputs","nnetInputs","letterToNnInput","letter","letterMap","toLowerCase","getWeights","nnet","setWeights","noletter","a","b","c","d","e","f","g","h","j","k","l","m","n","o","p","q","r","s","t","u","v","w","y","z","indexToLetter","index","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","letterToIndex","letterToIndexMap","iii","totalOutputs","ti","nti","input","concat","rawResult","textResult","currentOutputChar","highestProbability","currentBestGuessOfLetter","nonTextOutput","result","expectedTextOutput","expectedNonTextOutput","parsedExpectedTextOutput","expectedOutput","textnnet","chartOptions","title","curveType","legend","historyData","chartData","chartType","data","options","BOARD_TEMPLATE","board","fill","getInitialBoard","wordList","fiveLetterWords","bottomContainer","flexGrow","GameScreen","useState","guessList","setGuessList","inputWord","setInputWord","setNnStatus","certainty","setCertainty","numberOfPossibleAnswers","setNumberOfPossibleAnswers","speed","setSpeed","setLayers","setLearningRate","setMomentum","nnGuess","setNnGuess","setNnBestValidGuess","setRandomGuess","gameOver","setGameOver","endGameOnGuessWithDisabledLetter","setEndGameOnGuessWithDisabledLetter","trainWithValidRandomGuess","setTrainWithValidRandomGuess","running","setRunning","trainingMode","setTrainingMode","gamesPlayed","setGamesPlayed","setCurrentWordIndex","turnsPlayed","setTurnsPlayed","turnsPlayedByAi","setTurnsPlayedByAi","nnError","setnnError","setTrainingList","scoreList","scoreHistory","setScoreHistory","gamesWon","setGamesWon","disabledLetters","setDisabledLetters","wordToGuess","useRef","wordToGuessIndex","useEffect","newWord","len","randomIndex","floor","word","getRandomWord","current","guessLen","getExpectedOutput","list","split","setTimeout","runNNet","useCallback","DELETE","prev","slice","cw","gl","dl","flw","correctWord","console","log","disabledLettersInput","disabledLetter","presentLettersInput","correctLettersInput","guess","thisLetterindex","gameProgressInput","totalTurns","currentTurn","turnsArray","generateGameProgress","rawOutput","rawGuess","getHighestNumberIndex","sh","nnBestGuess","invalid","splice","includesDisabledLetter","trainingCount","randomWordLoop","randomWordIndex","randomInteger","newRandomWord","aDifferentResult","newGuessIndex","newGuessWord","window","onmessage","event","useMemo","line","char","colIndex","getWordleEmoji","rows","name","value","toFixed","Container","maxWidth","Grid","spacing","HistoryChart","item","md","Button","onClick","TextNNet","id","Slider","defaultValue","valueLabelDisplay","onChange","step","marks","min","max","TextField","label","helperText","test","target","parseFloat","aria-label","FormControlLabel","control","Switch","defaultChecked","TableContainer","Paper","Table","TableBody","TableRow","border","TableCell","scope","align","_","guessLetter","letterToShow","mh2","arrayOfNumbers","currentBestGuessOfIndex","number","numberOfOptions","activeResultIndex","expectedResult","stringArray","App","SafeAreaView"],"mappings":"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AC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIpE,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIqE,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIxC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIyC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,IAClIC,EAAG,CAAC,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,KAEtIvF,KAAKwF,cAAgB,SAASC,GAC1B,IAAIpH,EAAM,CACNqH,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,EAAG,IACHC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,IACJC,GAAI,KAER,OAAOnH,KAAKqD,gBAAkBhF,EAAIoH,GAAOlG,cAAgBlB,EAAIoH,IAEjEzF,KAAKoH,cAAgB,SAAS3D,GAE1B,OADAA,EAASA,EAAOE,cACT3D,KAAKqH,iBAAiB5D,IAEjCzD,KAAKqH,iBAAmB,CACpBrD,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHC,EAAG,EACHpE,EAAG,EACHqE,EAAG,EACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHC,EAAG,GACHxC,EAAG,GACHyC,EAAG,GACHC,EAAG,IAEP,IAAK,IAAIpF,EAAI,EAAGA,EAAI+C,EAAW5C,OAAQH,IACnC,IAAK,IAAIU,EAAK,EAAGA,EAAKqC,EAAW/C,GAAIU,IAEjC,IAAK,IAAIyG,EAAM,EAAGA,EAAM,GAAIA,IACxBtH,KAAKuD,WAAWnD,KAAK,CAAC,IAKlC,IAAK,IAAID,EAAI,EAAGA,EAAIgD,EAAc7C,OAAQH,IACtCH,KAAKuD,WAAWnD,KAAK+C,EAAchD,IAEvC,IAAIoH,EAAe,EACfnE,GAAeA,EAAc,IAC7BmE,GAA4C,GAAdnE,GAE9BE,GAAkBA,EAAiB,IACnCiE,GAA8BjE,GAElCtD,KAAK6D,KAAO,IAAIrE,EAAKQ,KAAKuD,WAAYvD,KAAKuD,WAAWjD,OAAQL,EAAQsH,EAAc1H,GAAc,EAAOE,GAGzGC,KAAK8B,KAAO,SAAS0F,EAAIC,GACrB,IAAIC,EAAQ,GACZ,IAAK,IAAIvH,EAAI,EAAGA,EAAIqH,EAAGlH,OAAQH,IAC3B,IAAK,IAAIU,EAAK,EAAGA,EAAK2G,EAAGrH,GAAGG,OAAQO,IAEhC6G,EAAMtH,QAAQJ,KAAKwD,gBAAgBgE,EAAGrH,GAAGU,KAGjD6G,EAAQA,EAAMC,OAAOF,GACrB,IAAIG,EAAY5H,KAAK6D,KAAK/B,KAAK4F,GAC3BG,EAAa,GACbC,EAAoB,EACpB3H,EAAI,EACJ4H,EAAqB,EACrBC,EAA2B,KAC3BC,EAAgB,GAmBpB,OAlBAL,EAAUhH,QAAQsH,IACVJ,EAAoB9H,KAAKoD,aACrB8E,EAASH,IACTA,EAAqBG,EACrBF,EAA2BhI,KAAKwF,cAAcrF,IAEzC,IAALA,GACAA,EAAI,EACJ0H,GAA0BG,EAC1BD,EAAqB,EACrBD,KAEA3H,KAGJ8H,EAAc7H,KAAK8H,KAGpB,CACHnK,KAAMiC,KAAKqD,gBAAkBwE,EAAWtI,cAAgBsI,EACxDvE,eAAgB2E,IAIxBjI,KAAK0B,MAAQ,SAAS8F,EAAK,KAAMC,EAAM,KAAMU,EAAqB,GAAIC,EAAwB,IAC1F,IAAIV,EAAQ,KACZ,GAAU,MAANF,GAAqB,MAAPC,EAAa,CAC3BC,EAAQ,GACR,IAAK,IAAIvH,EAAI,EAAGA,EAAIqH,EAAGlH,OAAQH,IAC3B,IAAK,IAAIU,EAAK,EAAGA,EAAK2G,EAAGrH,GAAGG,OAAQO,IAEhC6G,EAAMtH,QAAQJ,KAAKwD,gBAAgBgE,EAAGrH,GAAGU,KAGjD6G,EAAQA,EAAMC,OAAOF,GAGzBU,EAAqBA,EAAqBA,EAAmBxE,cAAgB,GAC7E,IAAI0E,EAA2B,GAC/B,IAAK,IAAIlI,EAAI,EAAGA,EAAIgI,EAAmB7H,OAAQH,IAC3CkI,EAAyBjI,QAAQJ,KAAK0D,UAAUyE,EAAmBhI,KAEvE,IAAImI,EAAiB,IAAID,KAA6BD,GACtDpI,KAAK6D,KAAKnC,MAAMgG,EAAOY,K,ICpL/BC,E,wICRGC,GAAe,CACpBC,MAAO,WACPC,UAAW,WACXC,OAAQ,CAAErN,SAAU,WA6CP2C,IAzBA9C,IAAWC,OAAO,CAC/BgC,IAAK,CACHC,cAAe,MACfC,aAAc,GAEhBC,KAAM,CACJC,QAAS,EACTC,kBAAmB,EACnBC,OAAQ,EACRC,aAAc,EACdC,YAAa,EACbC,YAAa,SAEfC,aAAc,CACZD,YAAa,QAEfE,KAAM,CACJrC,MAAO,QACPE,SAAU,IAEZoC,aAAc,CACZtC,MAAO,UAvCM,SAACwC,GAChB,IAAO0K,EAAe1K,EAAf0K,YACDC,EAAgB,CAAC,CAAC,OAAQ,uBAAwB,6BAAzC,WAA0ED,IAEzF,OACE,mCAEE,cAAC,KAAD,CACME,UAAU,YACVlM,MAAM,OACNqC,OAAO,QACP8J,KAAMF,EACNG,QAASR,SDVfS,GEVyB,WAE7B,IADA,IAAMC,EAAoB,GACjB/I,EAAI,EAAGA,ECLS,EDKQA,IAC/B+I,EAAM9I,KAAK,IAAIgB,MAAM,GAAG+H,KAAK,KAG/B,OAAOD,EFIcE,GAEnBC,GAAWC,EAwnBTpO,GAASC,IAAWC,OAAO,CAkB/BgC,IAAK,CACHE,aAAc,EACdD,cAAe,MACf8B,eAAgB,UAMlBoK,gBAAiB,CACfC,SAAU,EACVlM,aAAc,GACd4B,WAAY,SACZC,eAAgB,cAoBLsK,GAzqBI,WACjB,MAAkCC,mBAAmB,IAArD,WAAOC,EAAP,KAAkBC,EAAlB,KACA,EAAkCF,mBAAiB,IAAnD,WAAOG,EAAP,KAAkBC,EAAlB,KACA,EAAoCJ,mBAAiB,IAArD,WACA,GADA,UACgCA,mBAAiB,KAAjD,WAAiBK,GAAjB,WACA,EAAkCL,mBAAiB,GAAnD,WAAOM,EAAP,KAAkBC,EAAlB,KACA,EAA8DP,mBAAiB,GAA/E,WAAOQ,EAAP,KAAgCC,EAAhC,KACA,EAA0CT,mBAAiB,GAA3D,WACA,GADA,UACkEA,mBAAiB,IAAnF,WACA,GADA,UAC0BA,mBAAiB,IAA3C,WAAOU,EAAP,KAAcC,GAAd,KACA,GAA4BX,mBAAiB,GAA7C,aAAOzJ,GAAP,MAAeqK,GAAf,MACA,GAAwCZ,mBAAiB,MAAzD,aAAO7J,GAAP,MAAqB0K,GAArB,MACA,GAAgCb,mBAAiB,MAAjD,aAAO3J,GAAP,MAAiByK,GAAjB,MACA,GAA8Bd,mBAAiB,IAA/C,aAAOe,GAAP,MAAgBC,GAAhB,MACA,GAAgDhB,mBAAiB,IAAjE,aAAyBiB,IAAzB,aACA,GAAsCjB,mBAAiB,IAAvD,aAAoBkB,IAApB,aACA,GAAgClB,oBAAkB,GAAlD,aAAOmB,GAAP,MAAiBC,GAAjB,MACA,GAAgFpB,oBAAkB,GAAlG,aAAOqB,GAAP,MAAyCC,GAAzC,MACA,GAAgCtB,oBAAkB,GAAlD,aACA,IADA,YACkEA,oBAAkB,IAApF,aAAOuB,GAAP,MAAkCC,GAAlC,MACA,GAA8BxB,oBAAkB,GAAhD,aAAOyB,GAAP,MAAgBC,GAAhB,MAEA,GAAwC1B,oBAAkB,GAA1D,aAAO2B,GAAP,MAAqBC,GAArB,MACA,GAAsC5B,mBAAiB,GAAvD,aAAO6B,GAAP,MAAoBC,GAApB,MACA,GAAgD9B,mBAAiB,GAAjE,aAAyB+B,IAAzB,aACA,GAAsC/B,mBAAiB,GAAvD,aAAOgC,GAAP,MAAoBC,GAApB,MACA,GAA8CjC,mBAAiB,GAA/D,aAAOkC,GAAP,MAAwBC,GAAxB,MACA,GAA8BnC,mBAAiB,GAA/C,aAAOoC,GAAP,MAAgBC,GAAhB,MACA,GAA8CrC,mBAAiB,IAA/D,aACA,IADA,YACwCA,mBAAsC,KAA9E,aAAqBsC,IAArB,aACA,GAAkCtC,mBAA6B,IAA/D,aAAOuC,GAAP,MACA,IADA,MACwCvC,mBAAqC,CAAC,CAAC,EAAG,EAAG,MAArF,aAAOwC,GAAP,MAAqBC,GAArB,MAIA,GAAgCzC,mBAAiB,GAAjD,aAAO0C,GAAP,MAAiBC,GAAjB,MACA,GAA8C3C,mBAAmB,IAAjE,aAAO4C,GAAP,MAAwBC,GAAxB,MAEMC,GAAcC,iBAAe,SAC7BC,GAAmBD,iBAAe,GAExCE,qBAAU,WACR,IAAiB,IAAb9B,GAAoB,CACtB,IAAM+B,EEhDiB,SAACvD,GAC5B,IAAMwD,EAAMxD,EAAS/I,OACfwM,EAAclK,KAAKmK,MAAsB,IAAhBnK,KAAKD,UAAqBkK,EACzD,MAAO,CACLG,KAAM3D,EAASyD,GAAavN,cAC5BkG,MAAOqH,GF2CWG,CAAc5D,IAC9BmD,GAAYU,QAAUN,EAAQI,KAC9BN,GAAiBQ,QAAUN,EAAQnH,MACnCgG,GAAoBmB,EAAQnH,OAE5BqE,EAAa,IACbF,EAAa,IACb4B,GAAeD,GAAc,GAE3BJ,IACFL,IAAY,KAEb,CAACD,KAGJ8B,qBAAU,WACR,IAAMQ,EAAWxD,EAAUrJ,OAC3B,GAAIqJ,EAAUwD,EAAW,KAAOX,GAAYU,QACtC7B,KAIF9C,EAAS7G,MAAM,KAAM,KAAM,KAAM0L,GAAkBd,GAAiBjD,GAAUA,GAAS/I,OAAQoM,GAAiBQ,UAChHnB,GAAWxD,EAAS1E,KAAK3D,cAG3B8L,GAAgB,IAChBlB,IAAY,QAEP,GGzFgB,IHyFZqC,GAAwD,KAA5BxD,EAAUwD,EAAW,GACtD9B,IAAgB9C,IAClBA,EAAS7G,MAAM,KAAM,KAAM,KAAM0L,GAAkBd,GAAiBjD,GAAUA,GAAS/I,OAAQoM,GAAiBQ,UAChHnB,GAAWxD,EAAS1E,KAAK3D,cAE3B8L,GAAgB,IAChBlB,IAAY,OACP,CACL,IAAMuC,EAAiB,GAEvB1D,EAAU/I,SAAQ,SAAAoM,GAChBA,EAAKM,MAAM,IAAI1M,SAAQ,SAAA6C,GAEhB+I,GAAYU,QAAQzO,SAASgF,IAChC4J,EAAKjN,KAAKqD,SAKhB8I,GAAmBc,MAKpB,CAAC1D,EAAWwB,KAGfwB,qBAAU,WAERhB,GAAeD,GAAc,GAC7B6B,YAAW,WACTC,GAAQhB,GAAYU,QAASvD,EAAW2C,GAAiBjD,MACzDe,KAED,CAACkC,KAKJ,IAAMnO,GAAasP,uBACjB,SAAClP,GAEKA,IAAQvD,EAAoB0S,OAC9B5D,GAAa,SAAA6D,GAAI,OAAIA,EAAKC,MAAM,GAAI,MAC3BrP,IAAQvD,EAAoB6D,OACrC+K,GAAa,SAAA+D,GAAI,oBAAQA,GAAR,CAAc9D,EAAUtK,mBACzCuK,EAAa,KACW,IAAfvL,EAAI+B,QACbwJ,GAAa,SAAA6D,GACX,OAAIA,EAAKrN,OGzIS,IHyIiBgM,GAAgB7N,SAASF,GACnDoP,EAAOpP,EAEToP,OAIb,CAACrB,GAAiBzC,IAGd2D,GAAU,SAACK,EAAYC,EAAcC,EAAcC,GACvD,GAAK7C,IAAY5C,EAAjB,CAIA,IAAI0F,EAAcJ,EAAGP,MAAM,IAC3BY,QAAQC,IAAI,cAEZ,IADA,IAAIC,EAAuB,IAAIhN,MACtBjB,EAAI,EAAGA,EAAI,GAAIA,IACtBiO,EAAqBhO,KAAK,CAAC,IAG7B,IAAK,IAAID,EAAI,EAAGA,EAAI4N,EAAGzN,OAAQH,IAAK,CAClC,IAAIkO,EAAiBN,EAAG5N,GAExBiO,EAD0B7F,EAASnB,cAAciH,IACL,CAAC,GAS/C,IANA,IAAIC,EAAsB,IAAIlN,MAC1BmN,EAAsB,IAAInN,MAKrBjB,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1BoO,EAAoBnO,KAAK,YACzBkO,EAAoBlO,KAAK,IACzB,IAAK,IAAIoE,EAAI,EAAGA,EAAI,GAAIA,IACtB8J,EAAoBnO,GAAGC,KAAK,CAAC,IAOjC0N,EAAGlN,SAAQ,SAAC4N,EAAerO,GACzB,IAAK,IAAIU,EAAK,EAAGA,EAAK2N,EAAMlO,OAAQO,IAAM,CACxC,IAAM4N,EAAkBlG,EAASnB,cAAcoH,EAAM3N,IAEjDoN,EAAYxP,SAAS+P,EAAM3N,MAEzB2N,EAAM3N,KAAQoN,EAAYpN,GAC5B0N,EAAoB1N,GAAM2N,EAAM3N,GAEhCyN,EAAoBnO,GAAGsO,GAAmB,CAAC,QAMnD,IAAIC,EAqlBR,SAA8BC,EAAoBC,GAChD,IAAIC,EAAa,GACjB,KAAOA,EAAWvO,OAASqO,GACzBE,EAAWzO,KAAK,CAACwO,EAAcC,EAAWvO,OAAS,EAAI,IAEzD,OAAOuO,EA1lBmBC,CAAqB,EAAGnF,EAAUrJ,QAEtDoH,EAAS,CAAC,CAAC6G,GAAF,cAA4BG,GAAsBN,EAAlD,IAA2EE,EAAoB,IAA/F,IAAsGA,EAAoB,IAA1H,IAAiIA,EAAoB,IAArJ,IAA4JA,EAAoB,IAAhL,IAAuLA,EAAoB,MAExNtC,IAAgB,SAAA2B,GAAI,oBAAQA,GAAR,CAAcjG,OAGlCqC,EAAY,cAEZa,GAAe,IACfD,GAAoB,IAEpBD,GAAW,IAEX,IAAIqE,EAAYxG,EAASzG,KAAK4F,EAAM,GAAIA,EAAM,IAAIpE,eAK9C0L,EAAWC,GAAsBF,GACrC9E,EAAa+E,EAAShF,WACtB,IAMIkF,EANAC,EAAsBnB,EAAIgB,EAASvJ,OAAOlG,cAI1C6P,EAAkB,GAStB,GANAF,EAAE,IAAOhD,IACLA,GAAa5L,OAAS,KACxB4O,EAAGG,OAAO,EAAG,GAEfH,EAAG9O,KAAK,CAACmL,GAAayD,EAAShF,UAAW+E,EAAUrC,GAAiBQ,WACrEf,GAAgB+C,GACZI,GAAuBvB,EAAIoB,KAAiBpE,IAAoCE,KAGlF,GAFAmE,EAAU,YAENrE,GAEFnB,GAAa,SAAA+D,GAAI,oBAAQA,GAAR,CAAc,aAC1B,GAAI1C,GAA2B,CAEpC,IAAIsE,EAAgB,GAKC,SAAjBC,IAGF,IAFA,IAAIC,EAAkBC,GAAc,EAAG1B,EAAI1N,OAAS,GAChDqP,EAAgB3B,EAAIyB,GAAiBlQ,cAClC+P,GAAuBvB,EAAI4B,IAChCF,EAAkBC,GAAc,EAAG1B,EAAI1N,OAAS,GAChDqP,EAAgB3B,EAAIyB,GAAiBlQ,cAGvCqL,GAAe+E,GAEf,IAAIC,EAAmBxC,GAAkBW,EAAIC,EAAKA,EAAI1N,OAAQmP,GAC9DlH,EAAS7G,MAAM,KAAM,KAAM,KAAMkO,GACjC7D,GAAWxD,EAAS1E,KAAK3D,aACzB,IACI2P,EAAgBZ,GADI1G,EAASzG,KAAK4F,EAAM,GAAIA,EAAM,IAAIpE,gBACGmC,MACzDqK,EAAe9B,EAAI6B,GAAetQ,cAElC+P,GAAuBvB,EAAI+B,IAAiBP,EAAgB,GAC9DA,IACAhC,WAAWiC,EAAgBpF,IAE3BR,GAAa,SAAA+D,GAAI,oBAAQA,GAAR,CAAcgC,OAGnCH,SAIEL,IAAgB3C,GAAYU,SAC9Bb,GAAYD,GAAW,GAGrBzC,EAAUrJ,OAAS,GACrBuL,GAAmBD,GAAkB,GAEvChC,GAAa,SAAA+D,GAAI,oBAAQA,GAAR,CAAcwB,OAEjCzE,GAAWyE,EAAcC,KAU3BW,OAAOC,UANU,SAACC,GACE,cAAdA,EAAMlH,MACRyE,GAAQhB,GAAYU,QAASvD,EAAW2C,GAAiBjD,KAMjC6G,mBAAQ,WAClC,OAAKrF,GElRqB,SAACmC,EAAcrD,GAC3C,IAEIlH,EAAM,WAFKkH,EAAUA,EAAUrJ,OAAS,KAAO0M,EAEnBrD,EAAUrJ,OAAS,KAAzC,SAkBV,OAhBAqJ,EAAU/I,SAAQ,SAAAxD,GAChB,IAAI+S,EAAO,GAEX/S,EAAIkQ,MAAM,IAAI1M,SAAQ,SAACwP,EAAMC,GACvBD,IAASpD,EAAKqD,GAChBF,GAAQ,eACCnD,EAAKvO,SAAS2R,GACvBD,GAAQ,eAERA,GAAQ,kBAIZ1N,GAAU0N,EAAO,QAGZ1N,EFiQE6N,CAAe9D,GAAYU,QAASvD,GAHlC,KAIR,CAACkB,GAAUlB,IACCsC,GAAU2B,MAAM,EAAG,IAPlC,IAQM2C,GAAO,CACX,CACEC,KAAM,mBACNC,MAAOvG,GAET,CACEsG,KAAM,aACNC,MAAOhG,IAET,CACE+F,KAAM,uBACNC,MAAOzG,EAAU0G,QAAQ,IAE3B,CACEF,KAAM,SACNC,MAAOjE,GAAYU,SAMrB,CACEsD,KAAM,eACNC,MAAO/E,IAET,CACE8E,KAAM,eACNC,MAAOlF,IAET,CACEiF,KAAM,YACNC,MAAOrE,IAET,CACEoE,KAAM,YACNC,OAAQ7N,KAAKmK,MAAOX,GAAWb,GAAe,KAAO,KAAMmF,QAAQ,IAErE,CACEF,KAAM,mBACNC,MAAO3E,GAAQ4E,QAAQ,KAI3B,OACE,cAAChU,EAAA,EAAD,UACE,cAACiU,EAAA,EAAD,CAAWC,SAAS,KAApB,SACE,eAACC,EAAA,EAAD,CAAMxV,WAAS,EAACyV,QAAQ,IAAxB,UAEF,cAACC,GAAD,CAAcnI,YAAasD,KACvB,eAAC2E,EAAA,EAAD,CAAMG,MAAI,EAACC,GAAG,IAAd,WAEJ9F,IAAW,qCACX,cAAC+F,EAAA,EAAD,CAAQvS,SAAUwM,GAASpO,QAAQ,YAAYoU,QAAS,WACjD5I,IACHA,EAAW,IAAI6I,EACb,CAAC,CAAC,IACF,CAEE,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAE1B,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAAC,GAAI,CAA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","file":"static/js/app.5a220095.chunk.js","sourcesContent":["import React from 'react';\nimport {Pressable, StyleSheet, Text, View} from 'react-native';\n\ninterface KeyboardProps {\n  onKeyPress(char: string): void;\n  disabledKeyList: string[];\n}\n\nexport enum SpecialKeyboardKeys {\n  DELETE = 'delete',\n  GUESS = 'guess',\n}\n\nconst keySequence: string[][] = [\n  ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],\n  ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],\n  ['Z', 'X', 'C', 'V', 'B', 'N', 'M'],\n  // [SpecialKeyboardKeys.DELETE, SpecialKeyboardKeys.GUESS],\n];\n\nconst Keyboard = (props: KeyboardProps) => {\n  const {onKeyPress, disabledKeyList} = props;\n\n  return (\n    <>\n      {keySequence.map((row, rowIndex) => {\n        return (\n          <View key={'key-row-' + rowIndex} style={styles.row}>\n            {row.map(key => {\n              const isDisabled = disabledKeyList.includes(key);\n              return (\n                <Pressable\n                  key={key}\n                  disabled={isDisabled}\n                  onPress={() => onKeyPress(key)}>\n                  <View\n                    style={[styles.cell, isDisabled && styles.cellDisabled]}>\n                    <Text\n                      style={[styles.text, isDisabled && styles.textDisabled]}>\n                      {key}\n                    </Text>\n                  </View>\n                </Pressable>\n              );\n            })}\n          </View>\n        );\n      })}\n    </>\n  );\n};\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n    marginBottom: 5,\n  },\n  cell: {\n    padding: 5,\n    paddingHorizontal: 8,\n    margin: 4,\n    borderRadius: 2,\n    borderWidth: 1,\n    borderColor: 'black',\n  },\n  cellDisabled: {\n    borderColor: 'gray',\n  },\n  text: {\n    color: 'black',\n    fontSize: 16,\n  },\n  textDisabled: {\n    color: 'gray',\n  },\n});\n\nexport default Keyboard;\n","import React from 'react';\nimport {Linking, Platform, StyleSheet, Text, View} from 'react-native';\n\nconst HOME_URL = 'https://github.com/LonelyCpp/react-native-wordle';\n\nconst SourceLink = () => {\n  return (\n    <View style={styles.container}>\n      <Text\n        style={styles.subtitle}\n        accessibilityRole=\"link\"\n        // @ts-ignore (web only prop)\n        href={HOME_URL}\n        onPress={\n          Platform.OS !== 'web' ? () => Linking.openURL(HOME_URL) : undefined\n        }>\n        (github)\n      </Text>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    position: 'absolute',\n    right: 12,\n    top: 16,\n  },\n  subtitle: {\n    color: '#5998c5',\n    fontWeight: '400',\n    fontSize: 16,\n  },\n});\n\nexport default SourceLink;\n","import { Box, Typography } from '@mui/material';\nimport React from 'react';\nimport {StyleSheet, Text, View} from 'react-native';\n\nconst ScreenHeader = () => {\n  return (\n    <Box sx={{ width: '100%', textAlign: \"center\"}}>\n      <Typography variant=\"h4\" component=\"div\" gutterBottom>\n        wordle ai\n      </Typography>\n    </Box>\n  );\n};\n\nconst styles = StyleSheet.create({\n\n});\n\nexport default ScreenHeader;\n","import React from 'react';\nimport {StyleSheet, Text, View} from 'react-native';\n\nexport enum TextBlockState {\n  GUESS = 'guess',\n  CORRECT = 'correct',\n  POSSIBLE = 'possible',\n  INCORRECT = 'incorrect',\n}\n\nconst ColorMap: Record<TextBlockState, string> = {\n  [TextBlockState.GUESS]: 'transparent',\n  [TextBlockState.CORRECT]: '#76b041',\n  [TextBlockState.POSSIBLE]: '#FFC914',\n  [TextBlockState.INCORRECT]: '#8b939c',\n};\n\ninterface TextBlockProps {\n  text: string;\n  state: TextBlockState;\n}\n\nconst TextBlock = (props: TextBlockProps) => {\n  const {text, state} = props;\n\n  return (\n    <View\n      style={[\n        styles.container,\n        {\n          backgroundColor: ColorMap[state],\n        },\n      ]}>\n      <Text style={styles.text}>{text.toUpperCase()}</Text>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    width: 40,\n    height: 40,\n    borderWidth: 1,\n    borderRadius: 4,\n    borderColor: 'white',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: 16,\n    color: '#fff',\n    fontWeight: 'bold',\n  },\n});\n\nexport default TextBlock;\n","// FYI, this is a mess, with too much one-off stuff just to make it work\nexport default class NNEt {\n    constructor(inputs, numberOfNodes, numberOfLayers, outputs = 1, learningRate = 0.3, randomInitialWeights = false, momentum = 0.001) {\n        // array of inputs\n        this.inputs = inputs;\n        // e.x. [[1], [2], [1]]\n        // the number inside the innner arrays represents the number of inputs for each input node\n\n        // Number of outputs, each output has only one output value (which will always be a number between 0.0 and 1.0)\n        this.outputs = outputs;\n        \n        // number of nodes in hidden layer(s)\n        this.numberOfNodes = numberOfNodes;\n\n        // number of hidden layers\n        this.numberOfLayers = numberOfLayers;\n\n        // Learning rate\n        this.learningRate = learningRate;\n\n        this.momentum = momentum;\n        \n        // Randomize initial weights\n        this.randomInitialWeights = randomInitialWeights;\n        \n        // Here is our array of layers\n        this.layers = [];\n\n        this.globalError = 0;\n\n        // Layer Index\n        let i = 0;\n        \n        // Input layer\n        this.layers.push([]);\n        let inputId = 0;\n        while (this.layers[i].length < inputs.length) {\n            this.layers[i].push(new Node(inputs[inputId][0]));\n            inputId++;\n        }\n        i++;\n        \n        // Middle layer(s)\n        while (this.layers.length < numberOfLayers) {\n            this.layers.push([]);\n            if (i === 1) {\n                // Layer below the input layer, gets the number of input\n                while (this.layers[i].length < this.numberOfNodes) {\n                    this.layers[i].push(new Node(inputs.length, this.randomInitialWeights)); \n                }\n            } else {\n                // Any middle layer\n                while (this.layers[i].length < this.numberOfNodes) {\n                    this.layers[i].push(new Node(this.numberOfNodes, this.randomInitialWeights)); \n                }\n            }\n            i++;\n        }\n\n        // Output layer\n        this.layers.push([]);\n        while (this.layers[i].length < this.outputs) {\n            if (this.layers.length > 2) {\n                // There are middle layers, take the number of nodes as the number of inputs\n                this.layers[i].push(new Node(this.numberOfNodes, this.randomInitialWeights));\n            } else {\n                // No middle layers, take the input nodes directly\n                this.layers[i].push(new Node(inputs.length, this.randomInitialWeights)); \n            }\n        }\n    }\n    \n    // Get all the weights of the network\n    getWeights() {\n        return this.layers.map(layer => {\n            return layer.map(node => {\n                return { weights: node.weights, bias: node.bias };\n            });\n        });\n    }\n\n    // Set all the weights in the network\n    setWeights(weights) {\n        this.layers.forEach((layer, i) => {\n            layer.forEach((node, ii) => {\n                node.weights = weights[i][ii].weights;\n                node.bias = weights[i][ii].bias;\n            });\n        });\n    }\n\n    // TODO: Clean this up\n    // Train the network using inputs (or last inputs if not previously provided) and expected outputs\n    train(inputs, expectedOutputs) {\n        let error = 0;\n        // console.log(\"training nnet\")\n        if (!inputs) {\n            inputs = this.lastInputs;\n        }\n        let allOutputs = this.activateAllLayers(inputs);\n\n        // Creating an array in the shape of our network so we can store the deltas\n        let previousLayersDeltas = Array.apply(null, Array(this.layers.length)).map(function () { return []; });\n        \n        // get the delta from the bottom layer, \n        // and walk backwards through the layers\n        for (let i = this.layers.length - 1; i >= 0; i--) {\n            for (let ii = (this.layers[i].length - 1); ii >= 0; ii--) {\n                let nextLayersDelta = 0\n                // this layer's input is either the previous layer's output, or the original input\n                let thisLayersInput = i === 0 ? inputs[ii] : allOutputs[i - 1];\n                \n                // Delta for this node\n                let nodeDelta = 0;\n                if (i === this.layers.length - 1) {\n                    // this is the output layer, so we use the expected output for this node\n                    let outputDelta = (expectedOutputs[ii] - allOutputs[i][[ii]])\n                    nodeDelta = outputDelta;\n                    nextLayersDelta = this.layers[i][ii].train(thisLayersInput, nodeDelta, this.learningRate, this.momentum);\n                } else {\n                    // this is some middle or input layer, add up the previous layers together as they all connect together\n                    previousLayersDeltas[i + 1].forEach(delta => { \n                        nodeDelta = delta; \n                        nextLayersDelta += this.layers[i][ii].train(thisLayersInput, nodeDelta, this.learningRate, this.momentum);\n                    });\n                }\n                previousLayersDeltas[i].push(nextLayersDelta)\n                error = error + nextLayersDelta;\n            }\n        }\n        this.globalError = error;\n    }\n\n    activateAllLayers(inputs) {\n        let layerInputs;\n        let layerOutputs = [];\n        this.layers.forEach((layer, i) => {\n            layerOutputs.push([]);\n            layer.forEach((node, ii) => {\n                if (i === 0) {\n                    // Send the set of inputs for the input layer\n                    layerOutputs[i].push(node.fire(inputs[ii]));\n                } else {\n                    // Otherwise, send the output from the previous layer\n                    layerOutputs[i].push(node.fire(layerInputs));\n                }\n            });\n            // inputs for the next layer are outputs from this layer\n            layerInputs = layerOutputs[i];\n        });\n        // final layer has only one output\n        return layerOutputs;\n    }\n    fire(inputs) {\n        this.lastInputs = inputs;\n        let allOutputs = this.activateAllLayers(inputs);\n        // return the final output layer\n        return allOutputs[this.layers.length - 1]\n    }\n}\n\nclass Node {\n    constructor(inputs, randomInitialWeights) {\n        // number of inputs\n        this.inputs = inputs;\n        this.weights = Array.apply(null, Array(inputs)).map(function () { return startingWeight(randomInitialWeights); });\n        let bias = 0;\n        \n        // Try to initialize a neutral bias\n        this.weights.forEach(weight => {\n            if (weight > 0) {\n                bias = bias - weight;\n            } else {\n                bias = bias + weight;\n            }\n        });\n        this.bias = bias;\n        this.previousAdjustments = Array.apply(null, Array(inputs)).map(function () { return startingWeight(randomInitialWeights); });\n    }\n    // inputs = [];\n\n    train(inputs, correction, learningRate, momentum) {\n        let actualOutput = activation(inputs, this.weights, this.bias)\n\n        \n        for (let i = 0; i < inputs.length; i++) {\n            let weightAdjustment = correction * sigmoidDerivative(actualOutput, learningRate) * inputs[i];\n            let momentumAdjustment = this.previousAdjustments[i] * momentum;\n            this.previousAdjustments[i] = weightAdjustment;\n            this.weights[i] += weightAdjustment + momentumAdjustment;\n        }\n        this.bias = this.bias + learningRate * correction;\n        return correction * sigmoidDerivative(actualOutput, learningRate);\n    }\n    fire(inputs) {\n        if (inputs.length > this.weights.length) {\n            throw new Error(\"too many inputs\");\n        }\n        let sum = activation(inputs, this.weights, this.bias)\n        let output = sigmoid(sum);\n        if (output === 0 || output === 1) {\n            throw Error(\"output out of bounds!!!\")\n        }\n        return output;\n    }\n}\n\nfunction startingWeight(random) {\n    return random ? Math.random() : 0;\n}\nfunction sigmoid(x) {\n    let smaller = x;\n    return 1 / (1 + Math.exp(-smaller));\n} \nfunction sigmoidDerivative(x, learningRate) {\n    const fx = sigmoid(x);\n    return fx * (1 + learningRate - fx);\n}\n\nfunction activation(inputs, weights, bias) {\n    let sum = 0;\n    for (let i = 0; i < inputs.length; i++) {\n        sum += weights[i] * inputs[i]\n    }\n    return sum += bias;\n}","\nimport NNEt from \"./nnet\";\n\n// Work in progress, not usable...\nexport default class TextNNet {\n    constructor(textInputs, nonTextInputs, outputChars = 0, outputUpperCase, nonTextOutputs, layers, learningRate, momentum) {\n        // array of inputs\n        this.nonTextInputs = nonTextInputs;\n        this.textInputs = textInputs;\n        this.nnetInputs = [];\n        this.outputChars = outputChars;\n        this.outputUpperCase = outputUpperCase;\n        this.letterToNnInput = function(letter) {\n            return this.letterMap[letter.toLowerCase()];\n        };\n        this.getWeights = function() {\n            return this.nnet.getWeights();\n        };\n        this.setWeights = function(weights) {\n            this.nnet.setWeights(weights);\n        }\n        this.letterMap = {\n            noletter: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            a: [[1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            b: [[0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            c: [[0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            d: [[0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            e: [[0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            f: [[0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            g: [[0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            h: [[0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            i: [[0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            j: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            k: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            l: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            m: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            n: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            o: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            p: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            q: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0], [0]],\n            r: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0], [0]],\n            s: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0], [0]],\n            t: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0], [0]],\n            u: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0], [0]],\n            v: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0], [0]],\n            w: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0], [0]],\n            x: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0], [0]],\n            y: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1], [0]],\n            z: [[0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [0], [1]]\n        }\n        this.indexToLetter = function(index) {\n            let map = { \n                0: \"a\",\n                1: \"b\",\n                2: \"c\",\n                3: \"d\",\n                4: \"e\",\n                5: \"f\",\n                6: \"g\",\n                7: \"h\",\n                8: \"i\",\n                9: \"j\",\n                10: \"k\",\n                11: \"l\",\n                12: \"m\",\n                13: \"n\",\n                14: \"o\",\n                15: \"p\",\n                16: \"q\",\n                17: \"r\",\n                18: \"s\",\n                19: \"t\",\n                20: \"u\",\n                21: \"v\",\n                22: \"w\",\n                23: \"x\",\n                24: \"y\",\n                25: \"z\"\n            };\n            return this.outputUpperCase ? map[index].toUpperCase() : map[index]; \n        }\n        this.letterToIndex = function(letter) {\n            letter = letter.toLowerCase();\n            return this.letterToIndexMap[letter];\n        }\n        this.letterToIndexMap = {\n            a: 0,\n            b: 1,\n            c: 2,\n            d: 3,\n            e: 4,\n            f: 5,\n            g: 6,\n            h: 7,\n            i: 8,\n            j: 9,\n            k: 10,\n            l: 11,\n            m: 12,\n            n: 13,\n            o: 14,\n            p: 15,\n            q: 16,\n            r: 17,\n            s: 18,\n            t: 19,\n            u: 20,\n            v: 21,\n            w: 22,\n            x: 23,\n            y: 24,\n            z: 25\n        }\n        for (let i = 0; i < textInputs.length; i++) {\n            for (let ii = 0; ii < textInputs[i]; ii++) {\n\n                for (let iii = 0; iii < 26; iii++) {\n                    this.nnetInputs.push([1]);\n                }\n                // this.nnetInputs.push([26]);\n            }\n        }\n        for (let i = 0; i < nonTextInputs.length; i++) {\n            this.nnetInputs.push(nonTextInputs[i]);\n        }\n        let totalOutputs = 0;\n        if (outputChars && outputChars > 0) {\n            totalOutputs = totalOutputs + outputChars * 26;\n        }\n        if (nonTextOutputs && nonTextOutputs > 0) {\n            totalOutputs = totalOutputs + nonTextOutputs;\n        }\n        this.nnet = new NNEt(this.nnetInputs, this.nnetInputs.length, layers, totalOutputs, learningRate, false, momentum);\n        \n        // nti = non text inputs\n        this.fire = function(ti, nti) {\n            let input = [];\n            for (let i = 0; i < ti.length; i++) {\n                for (let ii = 0; ii < ti[i].length; ii++) \n                {\n                    input.push(...this.letterToNnInput(ti[i][ii]));\n                }\n            }\n            input = input.concat(nti);\n            let rawResult = this.nnet.fire(input);\n            let textResult = \"\";\n            let currentOutputChar = 0;\n            let i = 0;\n            let highestProbability = 0;\n            let currentBestGuessOfLetter = null;\n            let nonTextOutput = [];\n            rawResult.forEach(result => {\n                if (currentOutputChar < this.outputChars) {\n                    if (result > highestProbability) {\n                        highestProbability = result;\n                        currentBestGuessOfLetter = this.indexToLetter(i);\n                    }\n                    if (i == 25) {\n                        i = 0;\n                        textResult = textResult + currentBestGuessOfLetter;\n                        highestProbability = 0;\n                        currentOutputChar++;\n                    } else {\n                        i++;\n                    }\n                } else {\n                    nonTextOutput.push(result);\n                }\n            });\n            return {\n                text: this.outputUpperCase ? textResult.toUpperCase() : textResult,\n                nonTextOutputs: nonTextOutput\n            };\n        }\n\n        this.train = function(ti = null, nti = null, expectedTextOutput = \"\", expectedNonTextOutput = []) {\n            let input = null;\n            if (ti != null && nti != null) {\n                input = [];\n                for (let i = 0; i < ti.length; i++) {\n                    for (let ii = 0; ii < ti[i].length; ii++) \n                    {\n                        input.push(...this.letterToNnInput(ti[i][ii]));\n                    }\n                }\n                input = input.concat(nti);\n            }\n\n            expectedTextOutput = expectedTextOutput ? expectedTextOutput.toLowerCase() : \"\";\n            let parsedExpectedTextOutput = [];\n            for (let i = 0; i < expectedTextOutput.length; i++) {\n                parsedExpectedTextOutput.push(...this.letterMap[expectedTextOutput[i]]);\n            }\n            let expectedOutput = [...parsedExpectedTextOutput, ...expectedNonTextOutput]\n            this.nnet.train(input, expectedOutput);\n        }\n\n    }\n}\n\nfunction blankLetter() { return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; }\nfunction text(length) { \n    let text = [];\n    for (let i = 0; i < length; i++) {\n        text.push(blankLetter());\n    }\n    return text;\n}","import React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';\nimport {StyleSheet, Text, View, Clipboard, Platform, TextInputComponent} from 'react-native';\n// import Button from './components/Button';\nimport Keyboard, {SpecialKeyboardKeys} from './components/Keyboard';\nimport TextBlock, {TextBlockState} from './components/TextBlock';\nimport {MAX_GUESSES, MAX_WORD_LEN} from './constants/gameConstants';\nimport {getInitialBoard, getRandomWord, getWordleEmoji} from './gameUtils';\nimport TextNNet  from '../../../neuralnet/textnnet';\nimport fiveLetterWords from './constants/fiveLetterWords.json';\nimport {Button, FormGroup, Switch, FormControlLabel, Box, Container, TableContainer, Table, TableCell, TableRow, Paper, TableBody, TableHead, Grid, Slider, Typography, TextField, Divider} from '@mui/material';\nimport { Chart } from \"react-google-charts\";\nimport HistoryChart from './components/HistoryChart';\n\nconst BOARD_TEMPLATE = getInitialBoard();\nlet textnnet: TextNNet;\nlet wordList = fiveLetterWords;\n\nconst GameScreen = () => {\n  const [guessList, setGuessList] = useState<string[]>([]);\n  const [inputWord, setInputWord] = useState<string>('');\n  const [firstGuess, setFirstGuess] = useState<string>('');\n  const [nnStatus, setNnStatus] = useState<string>('');\n  const [certainty, setCertainty] = useState<number>(0);\n  const [numberOfPossibleAnswers, setNumberOfPossibleAnswers] = useState<number>(0);\n  const [randomGuesses, setRandomGuesses] = useState<number>(0);\n  const [timesToTrainWithValidWord, setTimesToTrainWithValidWord] = useState<number>(1);\n  const [speed, setSpeed] = useState<number>(0);\n  const [layers, setLayers] = useState<number>(0);\n  const [learningRate, setLearningRate] = useState<number>(0.005);\n  const [momentum, setMomentum] = useState<number>(0.001);\n  const [nnGuess, setNnGuess] = useState<string>('');\n  const [nnBestValidGuess, setNnBestValidGuess] = useState<string>('');\n  const [randomGuess, setRandomGuess] = useState<string>('');\n  const [gameOver, setGameOver] = useState<boolean>(false);\n  const [endGameOnGuessWithDisabledLetter, setEndGameOnGuessWithDisabledLetter] = useState<boolean>(false);\n  const [hardMode, setHardMode] = useState<boolean>(false);\n  const [trainWithValidRandomGuess, setTrainWithValidRandomGuess] = useState<boolean>(false);\n  const [running, setRunning] = useState<boolean>(false);\n  // const [expectedResult, setExpectedResult] = useState<number[]>([]);\n  const [trainingMode, setTrainingMode] = useState<boolean>(true);\n  const [gamesPlayed, setGamesPlayed] = useState<number>(0);\n  const [currentWordIndex, setCurrentWordIndex] = useState<number>(0);\n  const [turnsPlayed, setTurnsPlayed] = useState<number>(0);\n  const [turnsPlayedByAi, setTurnsPlayedByAi] = useState<number>(0);\n  const [nnError, setnnError] = useState<number>(0);\n  const [originalWeights, setOriginalWeights] = useState<object>({});\n  const [trainingList, setTrainingList] = useState<(number[][] | string[][])[]>([]);\n  const [scoreList, setScoreList] = useState<[number, string][]>([]);\n  const [scoreHistory, setScoreHistory] = useState<[number, number, number][]>([[0, 0, 0]]);\n\n\n  \n  const [gamesWon, setGamesWon] = useState<number>(0);\n  const [disabledLetters, setDisabledLetters] = useState<string[]>([]);\n  \n  const wordToGuess = useRef<string>('xxxxx');\n  const wordToGuessIndex = useRef<number>(0);\n\n  useEffect(() => {\n    if (gameOver === false) {\n      const newWord = getRandomWord(wordList);\n      wordToGuess.current = newWord.word;\n      wordToGuessIndex.current = newWord.index\n      setCurrentWordIndex(newWord.index);\n      // setExpectedResult(getExpectedOutput(disabledLetters, wordList, wordList.length, newWord.index));\n      setInputWord('');\n      setGuessList([]);\n      setGamesPlayed(gamesPlayed + 1);\n    }\n    if (running) {\n      setGameOver(false)\n    }\n  }, [gameOver]);\n\n\n  useEffect(() => {\n    const guessLen = guessList.length;\n    if (guessList[guessLen - 1] === wordToGuess.current) {\n      if (trainingMode) {\n        // trainingList.forEach((trainingData => {\n        //   textnnet.train(trainingData[0], trainingData[1], null, expectedResult);\n        // }));\n        textnnet.train(null, null, null, getExpectedOutput(disabledLetters, wordList, wordList.length, wordToGuessIndex.current));\n        setnnError(textnnet.nnet.globalError);\n\n      }\n      setTrainingList([]);\n      setGameOver(true);\n      \n    } else if (guessLen === MAX_GUESSES || guessList[guessLen - 1] === \"\") {\n      if (trainingMode && textnnet) {\n        textnnet.train(null, null, null, getExpectedOutput(disabledLetters, wordList, wordList.length, wordToGuessIndex.current));\n        setnnError(textnnet.nnet.globalError);\n      }\n      setTrainingList([]);\n      setGameOver(true);\n    } else {\n      const list: string[] = [];\n  \n      guessList.forEach(word => {\n        word.split('').forEach(letter => {\n          // console.log({letter});\n          if (!wordToGuess.current.includes(letter)) {\n            list.push(letter);\n          }\n        });\n      });\n  \n      setDisabledLetters(list);\n    }\n    \n    const list: string[] = [];\n\n  }, [guessList, running])\n\n\n  useEffect(() => {\n    // fire the next turn when disabled letters are reset\n    setTurnsPlayed(turnsPlayed + 1);\n    setTimeout(() => {\n      runNNet(wordToGuess.current, guessList, disabledLetters, wordList);\n    },speed)\n    // window.postMessage('start nnet');\n  }, [disabledLetters])\n\n  // useEffect(() => {\n  // }, [turnsPlayed]);\n\n  const onKeyPress = useCallback(\n    (key: string) => {\n\n      if (key === SpecialKeyboardKeys.DELETE) {\n        setInputWord(prev => prev.slice(0, -1));\n      } else if (key === SpecialKeyboardKeys.GUESS) {\n        setGuessList(prev => [...prev, inputWord.toUpperCase()]);\n        setInputWord('');\n      } else if (key.length === 1) {\n        setInputWord(prev => {\n          if (prev.length < MAX_WORD_LEN && !disabledLetters.includes(key)) {\n            return prev + key;\n          }\n          return prev;\n        });\n      }\n    },\n    [disabledLetters, inputWord],\n  );\n\n  const runNNet = (cw: string, gl: string[], dl: string[], flw: string[]) => {\n    if (!running || !textnnet) {\n      return;\n    }\n\n    let correctWord = cw.split(\"\");\n    console.log(\"running...\")\n    let disabledLettersInput = new Array<number[]>();\n    for (let i = 0; i < 26; i++) {\n      disabledLettersInput.push([0]);\n    }\n\n    for (let i = 0; i < dl.length; i++) {\n      let disabledLetter = dl[i];\n      let disabledLetterIndex = textnnet.letterToIndex(disabledLetter);\n      disabledLettersInput[disabledLetterIndex] = [1];\n    }\n\n    let presentLettersInput = new Array<Array<number>[]>();\n    let correctLettersInput = new Array<string>();\n\n    // for (let i = 0; i < 26; i++) {\n    //   presentLettersInput.push([0]);\n    // }\n    for (let i = 0; i < 5; i++) {\n      correctLettersInput.push(\"noletter\");\n      presentLettersInput.push([]);\n      for (let j = 0; j < 26; j++) {\n        presentLettersInput[i].push([0]);\n      }\n\n    }\n    let presentLetters:string[][] = [];\n\n\n    gl.forEach((guess: string, i) => {\n      for (let ii = 0; ii < guess.length; ii++) {\n        const thisLetterindex = textnnet.letterToIndex(guess[ii]);\n        \n        if (correctWord.includes(guess[ii])) {\n          // presentLetters.push([guess[ii]]);\n          if (guess[ii] === correctWord[ii]) {\n            correctLettersInput[ii] = guess[ii];\n          } else {\n            presentLettersInput[i][thisLetterindex] = [1];\n          }\n        }\n      }\n    });\n\n    let gameProgressInput = generateGameProgress(6, guessList.length);\n\n    let input =  [[correctLettersInput], [...gameProgressInput, ...disabledLettersInput, ...presentLettersInput[0], ...presentLettersInput[1], ...presentLettersInput[2], ...presentLettersInput[3], ...presentLettersInput[4]]];\n\n    setTrainingList(prev => [...prev, input]);\n    \n    let timesTrained = 0;\n    setNnStatus(\"Playing...\");\n\n    setRandomGuess(\"\");\n    setNnBestValidGuess(\"\");\n\n    setNnGuess(\"\");\n\n    let rawOutput = textnnet.fire(input[0], input[1]).nonTextOutputs;\n\n\n\n    // Best overall guess from NN\n    let rawGuess = getHighestNumberIndex(rawOutput);\n    setCertainty(rawGuess.certainty);\n    let nnBestGuess: string = flw[rawGuess.index].toUpperCase();\n    // let sl = getScoresWithWords(rawOutput, flw);\n    // setScoreList(sl);\n    let turnPlayedByAi = true;\n    let invalid: string = \"\";\n\n    let sh: [number, number, number][];\n    sh = [...scoreHistory]\n    if (scoreHistory.length > 100) {\n      sh.splice(0, 1);\n    } \n    sh.push([gamesPlayed, rawGuess.certainty, rawOutput[wordToGuessIndex.current]]);\n    setScoreHistory(sh);\n    if (includesDisabledLetter(dl, nnBestGuess) && (endGameOnGuessWithDisabledLetter || trainWithValidRandomGuess)) {\n      invalid = \"(invalid)\";\n      // If the very best guess is not valid, do some stuff\n      if (endGameOnGuessWithDisabledLetter) {\n        // If we are supposed to end the game when a disabled letter is guessed, end it.\n        setGuessList(prev => [...prev, \"\"]);\n      } else if (trainWithValidRandomGuess) {\n\n        let trainingCount = 0;\n        // let aDifferentResult = getExpectedOutput(wordList.length, bestValidGuessIndex);\n        \n        \n        let newResult = \"\";\n        let randomWordLoop = () => {\n          let randomWordIndex = randomInteger(0, flw.length - 1);\n          let newRandomWord = flw[randomWordIndex].toUpperCase();\n          while (includesDisabledLetter(dl, newRandomWord)) {\n            randomWordIndex = randomInteger(0, flw.length - 1);\n            newRandomWord = flw[randomWordIndex].toUpperCase();\n          }\n          \n          setRandomGuess(newRandomWord);\n          \n          let aDifferentResult = getExpectedOutput(dl, flw, flw.length, randomWordIndex);\n          textnnet.train(null, null, null, aDifferentResult);\n          setnnError(textnnet.nnet.globalError);\n          let newGuessRawOutput = textnnet.fire(input[0], input[1]).nonTextOutputs;\n          let newGuessIndex = getHighestNumberIndex(newGuessRawOutput).index;\n          let newGuessWord = flw[newGuessIndex].toUpperCase();\n          \n          if (includesDisabledLetter(dl, newGuessWord) && trainingCount < 1) {\n            trainingCount++;\n            setTimeout(randomWordLoop, speed);\n          } else {\n            setGuessList(prev => [...prev, newRandomWord]);\n          }\n        }\n        randomWordLoop();\n      }\n\n    } else {\n      if (nnBestGuess === wordToGuess.current) {\n        setGamesWon(gamesWon + 1);\n      }\n\n      if (guessList.length > 0) {\n        setTurnsPlayedByAi(turnsPlayedByAi + 1);\n      }\n      setGuessList(prev => [...prev, nnBestGuess]);\n    }\n    setNnGuess(nnBestGuess + invalid)\n\n  };\n\n  const callback = (event: MessageEvent) => {\n    if (event.data == 'start nnet') {\n      runNNet(wordToGuess.current, guessList, disabledLetters, wordList);\n    }\n  };\n\n  window.onmessage = callback;\n  \n  const wordleEmoji: string = useMemo(() => {\n    if (!gameOver) {\n      return '';\n    }\n\n    return getWordleEmoji(wordToGuess.current, guessList);\n  }, [gameOver, guessList]);\n  const scores = scoreList.slice(0, 10);\n  const rows = [\n    {\n      name: \"Possible Answers\",\n      value: numberOfPossibleAnswers\n    },\n    {\n      name: \"Best Guess\",\n      value: nnGuess\n    },\n    {\n      name: \"Best Guess Certainty\",\n      value: certainty.toFixed(5)\n    },\n    {\n      name: \"Answer\",\n      value: wordToGuess.current\n    },\n    // {\n    //   name: \"Score of answer\",\n    //   value: scoreHistory[scoreHistory.length - 1]?\n    // },\n    {\n      name: \"Turns Played\",\n      value: turnsPlayed\n    },\n    {\n      name: \"Games Played\",\n      value: gamesPlayed\n    },\n    {\n      name: \"Games Won\",\n      value: gamesWon\n    },\n    {\n      name: \"Win Ratio\",\n      value: (Math.floor((gamesWon / gamesPlayed )* 100) / 100 ).toFixed(5)\n    },\n    {\n      name: \"Neural Net Error\",\n      value: nnError.toFixed(5)\n    }\n  ];\n\n  return (\n    <Box>\n      <Container maxWidth=\"md\">\n        <Grid container spacing=\"2\">\n\n      <HistoryChart historyData={scoreHistory}/>\n          <Grid item md=\"6\">\n            \n    {!running && <>\n      <Button disabled={running} variant=\"contained\" onClick={() => { \n        if (!textnnet) {\n          textnnet = new TextNNet(\n            [[5]], \n            [\n              // game progress\n              [1], [1], [1], [1], [1], [1],\n              // other inputs\n              [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1]], \n            0,\n            true,\n            wordList.length,\n            layers,\n            learningRate,\n            momentum);\n        }\n        if (!running) {\n          setRunning(true);\n        } else {\n          setRunning(false);\n        }\n        \n        } }>{ running ? \"Start AI\" : \"Start AI\"}</Button>\n    \n    <Typography variant=\"h5\">\n      Neural Network Options\n    </Typography>\n    <Typography id=\"non-linear-slider\" gutterBottom>\n      (you can't change these later)\n    </Typography>\n    <Typography id=\"non-linear-slider\" gutterBottom>\n      Middle Layers:\n    </Typography>\n\n      <Slider\n      disabled={textnnet}\n        defaultValue={layers}\n        // getAriaValueText={}\n        valueLabelDisplay=\"auto\"\n        onChange= {(e, value) => {\n          setLayers(value)\n        }}\n        step={1}\n        marks\n        min={0}\n        max={10}\n      />\n\n      <Typography id=\"non-linear-slider\" gutterBottom>\n        Number of answers:\n      </Typography>\n  \n        <Slider\n        disabled={textnnet}\n          defaultValue={wordList.length}\n          // getAriaValueText={}\n          valueLabelDisplay=\"auto\"\n          onChange= {(e, value) => {\n            wordList = fiveLetterWords.slice(0, value)\n            setNumberOfPossibleAnswers(value);\n          }}\n          step={1}\n          // marks\n          min={1}\n          max={fiveLetterWords.length}\n        />\n      \n      </>\n      }\n\n      <Typography variant=\"h5\">\n      Game/Training Options\n    </Typography>\n\n    <TextField \n      id=\"outlined-basic\" \n      label=\"Learning Rate (between 0 and 1)\" \n      variant=\"outlined\" \n      defaultValue={learningRate} \n      helperText=\"Changes can break the game\"\n      onChange={(e)=>{\n         if (/^(0(\\.\\d+)?|1(\\.0+)?)$/.test(e.target.value)) {\n           setLearningRate(parseFloat(e.target.value)); \n           if (textnnet) {\n             textnnet.nnet.learningRate = e.target.value;\n           }\n         }\n        \n        }}/>\n      <TextField \n      id=\"outlined-basic\" \n      label=\"Momentum (between 0 and 1\" \n      helperText=\"Changes this can break the game\"\n      variant=\"outlined\" \n      defaultValue={momentum} \n      onChange={(e)=>{\n        \n        if (/^(0(\\.\\d+)?|1(\\.0+)?)$/.test(e.target.value)) {\n          setMomentum(parseFloat(e.target.value)); \n          if (textnnet) {\n            textnnet.nnet.momentum = e.target.value;\n          }\n        }\n        }}/>\n    {/* <Typography id=\"non-linear-slider\" gutterBottom>\n        Learning Rate\n      </Typography>\n  \n        <Slider\n          defaultValue={learningRate}\n          // getAriaValueText={}\n          valueLabelDisplay=\"auto\"\n          onChange= {(e, value) => {\n            setLearningRate(parseFloat(value)); \n            if (textnnet) {\n              textnnet.nnet.learningRate = value;\n            }\n          }}\n          step={0.000000001}\n          // marks\n          min={0}\n          max={1}\n        /> */}\n      <Typography id=\"non-linear-slider\" gutterBottom>\n      Speed:\n    </Typography>\n\n      <Slider\n        aria-label=\"Speed\"\n        defaultValue={\"1\"}\n        // getAriaValueText={}\n        valueLabelDisplay=\"auto\"\n        onChange= {(e, value) => {\n          setSpeed(value)\n        }}\n        step={200}\n        marks\n        min={0}\n        max={3000}\n      />\n        <FormControlLabel control={\n          <Switch defaultChecked onChange={(e, value) => {\n            setTrainingMode(value);\n          }}/>\n        } label=\"Train with correct word after game\" />\n        <FormControlLabel control={\n          <Switch onChange={(e, value) => {\n            setEndGameOnGuessWithDisabledLetter(value)\n            if (value === false) {\n              setTrainWithValidRandomGuess(false);\n            }\n          }}/>\n        } label=\"End game on guesses with disabled letters\" />\n      { !endGameOnGuessWithDisabledLetter ? (<>\n        <FormControlLabel control={\n          <Switch onChange={(e, value) => {\n            setTrainWithValidRandomGuess(value)\n          }}/>\n        } label=\"Train with random valid guess if AI guesses disabled letter\" />\n      {trainWithValidRandomGuess && (<><Typography id=\"non-linear-slider\" gutterBottom>\n      Maximum to train after invalid guess:\n    </Typography>\n\n      <Slider\n        aria-label=\"Speed\"\n        defaultValue={\"1\"}\n        // getAriaValueText={}\n        valueLabelDisplay=\"auto\"\n        onChange= {(e, value) => {\n          setSpeed(value)\n        }}\n        step={1}\n        marks\n        min={1}\n        max={100}\n      />\n      </>)}\n      </>) : (<></>)}\n      \n      <Button variant=\"contained\" onClick={() => { setTurnsPlayedByAi(0); setTurnsPlayed(0); setGamesPlayed(0); setGamesWon(0); ; } }>Reset Statistics</Button>\n      <TableContainer component={Paper}>\n        \n      <Table>\n        {/* <TableHead>\n          <TableRow>\n            <TableCell>Dessert (100g serving)</TableCell>\n            <TableCell align=\"right\">Calories</TableCell>\n            <TableCell align=\"right\">Fat&nbsp;(g)</TableCell>\n            <TableCell align=\"right\">Carbs&nbsp;(g)</TableCell>\n            <TableCell align=\"right\">Protein&nbsp;(g)</TableCell>\n          </TableRow>\n        </TableHead> */}\n        <TableBody>\n          {rows.map((row) => (\n            <TableRow\n              key={row.name}\n              sx={{ '&:last-child td, &:last-child th': { border: 0 } }}\n            >\n              <TableCell component=\"th\" scope=\"row\">\n                {row.name}\n              </TableCell>\n              <TableCell align=\"right\">{row.value}</TableCell>\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n    </TableContainer>\n\n    </Grid>\n    <Grid item md=\"6\">\n\n\n      {BOARD_TEMPLATE.map((row, rowIndex) => {\n        return (\n          <View key={`row-${rowIndex}`} style={styles.row}>\n            {row.map((_, colIndex) => {\n              const guessLetter = guessList[rowIndex]?.[colIndex];\n              let state: TextBlockState = TextBlockState.GUESS;\n\n              if (guessLetter === undefined) {\n                state = TextBlockState.GUESS;\n              } else if (guessLetter === wordToGuess.current[colIndex]) {\n                state = TextBlockState.CORRECT;\n              } else if (wordToGuess.current.includes(guessLetter)) {\n                state = TextBlockState.POSSIBLE;\n              } else {\n                state = TextBlockState.INCORRECT;\n              }\n\n              const letterToShow =\n                rowIndex === guessList.length\n                  ? inputWord[colIndex]\n                  : guessLetter;\n\n              return (\n                <View style={styles.mh2} key={`col-${colIndex}`}>\n                  <TextBlock text={letterToShow || ''} state={state} />\n                </View>\n              );\n            })}\n          </View>\n        );\n      })}\n\n      <View style={styles.bottomContainer}>\n        <Keyboard\n          disabledKeyList={[\n            ...disabledLetters,\n            inputWord.length !== MAX_WORD_LEN\n              ? SpecialKeyboardKeys.GUESS\n              : '',\n          ]}\n          onKeyPress={onKeyPress}\n        />\n      </View>\n\n    {/* <Typography variant=\"h5\">\n      Top 10 Guesses\n    </Typography>\n      <TableContainer component={Paper}>\n      <Table>\n        <TableHead>\n          <TableRow>\n            <TableCell>Dessert (100g serving)</TableCell>\n            <TableCell align=\"right\">Calories</TableCell>\n            <TableCell align=\"right\">Fat&nbsp;(g)</TableCell>\n            <TableCell align=\"right\">Carbs&nbsp;(g)</TableCell>\n            <TableCell align=\"right\">Protein&nbsp;(g)</TableCell>\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {scores.map((score, i) => (\n            <TableRow\n              key={i}\n              sx={{ '&:last-child td, &:last-child th': { border: 0 } }}\n            >\n              <TableCell component=\"th\" scope=\"row\">\n                {i + 1}\n              </TableCell>\n              <TableCell align=\"right\">{score[1]}</TableCell>\n              <TableCell align=\"right\">{score[0]}</TableCell>\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n    </TableContainer> */}\n    </Grid>\n    </Grid>\n      </Container>\n    </Box>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // mb12: {\n  //   marginBottom: 12,\n  // },\n  // mh2: {\n  //   marginHorizontal: 2,\n  // },\n  // // button: {\n  // //   // maxWidth: '200px',\n  // //   width: '100%',\n  // // },\n  // fg1: {\n  //   flexGrow: 1,\n  // },\n  // textWhite: {\n  //   color: '#fff',\n  //   fontSize: 22,\n  // },\n  row: {\n    marginBottom: 4,\n    flexDirection: 'row',\n    justifyContent: 'center',\n  },\n  // buttons: {\n  //   maxWidth: 300,\n  //   justifyContent: 'center',\n  // },\n  bottomContainer: {\n    flexGrow: 1,\n    marginBottom: 16,\n    alignItems: 'center',\n    justifyContent: 'flex-end',\n  },\n  // score: {\n  //   color: '#fff',\n  //   fontSize: 14,\n  //   marginBottom: 12,\n  // },\n  // buttonRow: {\n  //   flexDirection: 'row',\n  // },\n  // buttonSpacer: {\n  //   width: 12,\n  // },\n  // gamesplayed: {\n  //   textAlign: \"left\",\n  //   color: '#fff',\n  //   width: '300px',\n  // }\n});\n\nexport default GameScreen;\n\n// const letterIndex = new Map<string, number>([\n//   [\"a\", 0],\n//   [\"b\", 1],\n//   [\"c\", 2],\n//   [\"d\", 3],\n//   [\"e\", 4],\n//   [\"f\", 5],\n//   [\"g\", 6],\n//   [\"h\", 7],\n//   [\"i\", 8],\n//   [\"j\", 9],\n//   [\"k\", 10],\n//   [\"l\", 11],\n//   [\"m\", 12],\n//   [\"n\", 13],\n//   [\"o\", 14],\n//   [\"p\", 15],\n//   [\"q\", 16],\n//   [\"r\", 17],\n//   [\"s\", 18],\n//   [\"t\", 19],\n//   [\"u\", 20],\n//   [\"v\", 21],\n//   [\"w\", 22],\n//   [\"x\", 23],\n//   [\"y\", 24],\n//   [\"z\", 25],\n// ]);\n\nfunction getBestValidGuess(scoresAndIndexes: {score: number, index: number, word: string }[], disabledLetters: string[]) {\n\n  let i = scoresAndIndexes.length;\n  let bestValidGuess;\n  while (!bestValidGuess && i > -1) {\n    i--;\n    let thisWord = wordList[scoresAndIndexes[i].index];\n    if (!includesDisabledLetter(disabledLetters, thisWord)) {\n      bestValidGuess = thisWord;\n    }\n  }\n  return bestValidGuess ? { word: bestValidGuess.toUpperCase(), index: i } : { word: \"\", index: 0 };\n}\n\nfunction getScoresWithWords(arrayOfNumbers: number[], words: string[]) {\n  let scoresAndIndexes: [number, string][] = [];\n  arrayOfNumbers.forEach((n, i) => {\n    scoresAndIndexes.push([n, words[i].toUpperCase()]);\n    // scoresAndIndexes[i].push(n);\n    // scoresAndIndexes[i].push()\n  })\n  scoresAndIndexes.sort((a, b) => {\n    return b[0] - a[0];\n  });\n  return scoresAndIndexes;\n}\n\nfunction getHighestNumberIndex(arrayOfNumbers: number[]) {\n\n  let highestProbability = 0;\n  let currentBestGuessOfIndex = -1;\n  arrayOfNumbers.forEach((number, i) => {\n    if (number > highestProbability) {\n      highestProbability = number;\n      currentBestGuessOfIndex = i;\n    }\n  });\n  return {index: currentBestGuessOfIndex, certainty: highestProbability };\n}\nfunction getExpectedOutput(disabledLetters: string[], wordList: string[], numberOfOptions: number, activeResultIndex: number) {\n  let expectedResult: number[] = []\n  for (var i = 0; i < numberOfOptions; i++) {\n    expectedResult.push(activeResultIndex === i ? 1 : (includesDisabledLetter(disabledLetters, wordList[i].toUpperCase()) ? 0 : .5));\n  }\n  return expectedResult;\n}\n\nfunction randomInteger(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// function hardModeValidation(correctLetters: string[], presentLetters: guess: string) {\n  \n// }\n\nfunction includesDisabledLetter(disabledLetters: string[], word: string) {\n  let stringArray = word.toUpperCase().split(\"\")\n  while (stringArray.length > 0) {\n    if (disabledLetters.includes(stringArray[0])) {\n      return true;\n    }\n    stringArray.splice(0, 1);\n  }\n  return false;\n}\n\nfunction generateGameProgress(totalTurns: number, currentTurn: number) {\n  let turnsArray = [];\n  while (turnsArray.length < totalTurns) {\n    turnsArray.push([currentTurn > turnsArray.length ? 0 : 1]);\n  }\n  return turnsArray;\n}","import React from 'react';\nimport Chart from 'react-google-charts';\nimport {Pressable, StyleSheet, Text, View} from 'react-native';\n\ninterface HistoryChartProps {\n  historyData: [number, number, number][];\n}const chartOptions = {\n  title: \"Accuracy\",\n  curveType: \"function\",\n  legend: { position: \"bottom\" },\n};\nconst Keyboard = (props: HistoryChartProps) => {\n  const {historyData} = props;\n  const chartData = [...[[\"Game\", \"Best Guess Certainty\", \"Correct Answer Certainty\"]], ...historyData];\n\n  return (\n    <>\n\n      <Chart\n            chartType=\"LineChart\"\n            width=\"100%\"\n            height=\"400px\"\n            data={chartData}\n            options={chartOptions}\n          />\n    </>\n  );\n};\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n    marginBottom: 5,\n  },\n  cell: {\n    padding: 5,\n    paddingHorizontal: 8,\n    margin: 4,\n    borderRadius: 2,\n    borderWidth: 1,\n    borderColor: 'black',\n  },\n  cellDisabled: {\n    borderColor: 'gray',\n  },\n  text: {\n    color: 'black',\n    fontSize: 16,\n  },\n  textDisabled: {\n    color: 'gray',\n  },\n});\n\nexport default Keyboard;\n","import fiveLetterWords from './constants/fiveLetterWords.json';\nimport {MAX_GUESSES} from './constants/gameConstants';\n\nexport const getInitialBoard = (): string[][] => {\n  const board: string[][] = [];\n  for (let i = 0; i < MAX_GUESSES; i++) {\n    board.push(new Array(5).fill(''));\n  }\n\n  return board;\n};\n\nexport const getRandomWord = (wordList: string[]): { word: string, index: number } => {\n  const len = wordList.length;\n  const randomIndex = Math.floor(Math.random() * 100000) % len;\n  return {\n    word: wordList[randomIndex].toUpperCase(),\n    index: randomIndex\n  };\n};\n\nexport const getWordleEmoji = (word: string, guessList: string[]): string => {\n  const hasWon = guessList[guessList.length - 1] === word;\n\n  let output = `Wordle ${hasWon ? guessList.length : 'x'}/${MAX_GUESSES}\\n\\n`;\n\n  guessList.forEach(row => {\n    let line = '';\n\n    row.split('').forEach((char, colIndex) => {\n      if (char === word[colIndex]) {\n        line += '🟩';\n      } else if (word.includes(char)) {\n        line += '🟨';\n      } else {\n        line += '⬜️';\n      }\n    });\n\n    output += line + '\\n';\n  });\n\n  return output;\n};\n","export const MAX_GUESSES = 6;\nexport const MAX_WORD_LEN = 5;\n","import React from 'react';\nimport {SafeAreaView, StyleSheet, View} from 'react-native';\nimport SourceLink from './app/components/SourceLink';\nimport ScreenHeader from './app/components/ScreenHeader';\nimport GameScreen from './app/GameScreen';\n\nexport default function App() {\n  return (\n    <View>\n      <SafeAreaView>\n        <ScreenHeader />\n        <GameScreen />\n        <SourceLink />\n      </SafeAreaView>\n    </View>\n    \n  );\n}\n\nconst styles = StyleSheet.create({\n  // container: {\n  //   flex: 1,\n  //   backgroundColor: '#000',\n  // },\n});\n"],"sourceRoot":""}